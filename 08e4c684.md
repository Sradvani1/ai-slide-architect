# SlidesEdu Image Generation Refactor Spec

Owner: SlidesEdu  
Audience: Antigravity AI (implementation in Google Antigravity + Firebase + Vercel)  
File purpose: Detailed engineering spec for refactoring the image prompting + image generation pipeline to produce **consistent, high-quality educational visual aids** for slide decks.

---

## 1. Context & Goals

SlidesEdu generates AI-powered slide decks (Gemini 2.5 Pro) and associated images (Gemini 3 Pro Image). The images are **supplemental visual aids** embedded into slides, not full slide screenshots. They should:

- Support the **core concept** of each slide (one main idea per image)
- Be **simple, clean, and uncluttered**
- Use a **flat vector educational style** with a **white background**
- Have **high contrast** and **generous whitespace** for classroom projection
- Use **no text or tightly limited labels** to avoid clutter and gibberish
- Be **consistent across slides** within a deck

This spec refactors the image pipeline to:

1. Move from a single freeform `imagePrompt` string → a structured `ImageSpec` JSON per slide.
2. Use a **deterministic formatter** to turn `ImageSpec` into a full paragraph prompt shown to users and sent to Gemini 3 Pro Image.
3. Fix the Gemini 3 Pro Image API usage (config shape, aspect ratio, image size, response modalities).
4. Preserve UX features: users see and can regenerate/edit a **full image prompt** per slide.

---

## 2. Current Implementation (Summary)

### 2.1 Slide Generation (`generateSlidesFromDocument`)

- Uses `gemini-2.5-pro` to generate slides with the following schema:
  - `title: string`
  - `content: string[]`
  - `layout: "Title Slide" | "Content"`
  - `imagePrompt: string`
  - `speakerNotes: string`
  - `sources?: string[]`
- Prompt includes an **IMAGE PROMPTING GUIDELINES** section that asks the model to write an image description string.
- Structured output is configured via:
  - `config.responseMimeType = "application/json"`
  - `config.responseSchema = slidesSchema` (for non-web-search mode).

### 2.2 Image Rendering (`generateImage`)

```ts
export const generateImage = async (
  prompt: string,
  gradeLevel: string,
  temperature: number = 0.3,
  aspectRatio: '16:9' | '1:1' = '16:9'
): Promise<Blob> => {
  const enhancedPrompt = `
    IMAGE SUBJECT
    ${prompt}

    TARGET AUDIENCE
    ${gradeLevel} Grade Students

    ${IMAGE_STYLE_GUIDE}`;

  const response = await retryWithBackoff(() => ai.models.generateContent({
    model: "gemini-3-pro-image-preview",
    contents: enhancedPrompt,
    config: {
      temperature: temperature,
      aspectRatio: aspectRatio,
    } as any,
  }));

  // then parse inlineData → Blob
};
```

Notes:
- `IMAGE_STYLE_GUIDE` enforces flat vector, white background, minimal text.
- `aspectRatio` is passed directly in `config` (likely incorrect per Gemini 3 image docs, which expect `imageConfig` and `responseModalities`).

### 2.3 Regeneration (`regenerateImagePrompt`)

- `regenerateImagePrompt()` calls `gemini-2.5-pro` to produce a new prompt string given slide title/content/grade/subject.
- Uses similar guidelines (visual description only, no style words, no complex diagrams, keep uncluttered).

### 2.4 Pain Points

- `imagePrompt` strings are underspecified (no strong control over composition, number of objects, what to avoid).
- Style guide is generic; different slides drift stylistically.
- API config for `gemini-3-pro-image-preview` is likely not compliant with current docs (no `imageConfig`, no `responseModalities`).
- Harder to debug: when an image is cluttered/odd, it’s unclear what in the prompt caused it.

---

## 3. Target Architecture

### 3.1 High-Level Design

**Replace** the freeform `imagePrompt: string` with a structured JSON spec per slide:

- `imageSpec: ImageSpec` — the semantic intent (what to draw, composition, text policy, etc.)
- `renderedImagePrompt: string` — a deterministic, human-readable prompt paragraph derived from `imageSpec`

The flow becomes:

1. `generateSlidesFromDocument()` (Gemini 2.5 Pro):
   - Generates slide objects, each containing `imageSpec` instead of `imagePrompt`.
2. Local app code (no extra API call):
   - Validates and sanitizes `imageSpec`.
   - Runs `formatImageSpec(imageSpec, context)` → `renderedImagePrompt`.
   - Stores both `imageSpec` and `renderedImagePrompt`.
3. `generateImageFromSpec()` (Gemini 3 Pro Image):
   - Uses `renderedImagePrompt` as `contents`.
   - Passes a correct `imageConfig` and `responseModalities` to `gemini-3-pro-image-preview`.
4. UI:
   - Shows `renderedImagePrompt` per slide.
   - Allows **Regenerate Image** (same spec), **Regenerate Visual Idea** (new spec via Gemini), and **Edit Prompt** (advanced).

### 3.2 No Additional Latency or Extra Calls (Baseline)

- Slide gen: same number of calls (1).
- Image gen: same number of calls (1 per image).
- Prompt construction: moved to deterministic local formatting (cheap).
- Additional calls occur only if we choose to implement “regenerate visual idea” (new spec generation), analogous to current `regenerateImagePrompt()` behavior.

---

## 4. New Types & Interfaces

### 4.1 ImageSpec

Create `types/image.ts` (or expand `types.ts`):

```ts
export type ImageTextPolicy = 'NO_LABELS' | 'LIMITED_LABELS_1_TO_3';

export type ImageLayout =
  | 'single-focal-subject-centered'
  | 'balanced-pair'
  | 'simple-sequence-2-panel';

export type Viewpoint =
  | 'front'
  | 'three-quarter'
  | 'side'
  | 'overhead'
  | 'child-eye-level';

export type Whitespace = 'generous' | 'moderate';

export interface ImageSpec {
  // WHAT: semantic content
  primaryFocal: string;       // Single main visible concept/action (e.g., "sunlight hitting a green leaf")
  subjects: string[];         // 2–5 concrete objects (e.g., ["sun", "leaf", "water droplet"]) 
  actions?: string[];         // 0–3 verbs (e.g., ["shining", "absorbing"])
  mustInclude: string[];      // 2–6 critical visible elements (e.g., ["bright sun", "green leaf"])
  avoid: string[];            // clutter/confusers (e.g., ["chemical equations", "human figures"])

  // HOW: composition & layout
  composition: {
    layout: ImageLayout;
    viewpoint: Viewpoint;
    whitespace: Whitespace;   // For slides we want 'generous' by default
  };

  // TEXT in the image
  textPolicy: ImageTextPolicy;  // Usually 'NO_LABELS'
  allowedLabels?: string[];     // 0–3 labels if LIMITED_LABELS_1_TO_3

  // Palette
  colors?: string[];            // 0–5 main colors

  // Additional negative constraints
  negativePrompt?: string[];    // 0–10 extra failure modes to avoid
}
```

### 4.2 Slide Type Update

Update `Slide` interface to include:

```ts
export interface Slide {
  // existing fields
  title: string;
  content: string[];
  layout: 'Title Slide' | 'Content';
  speakerNotes: string;
  sources?: string[];

  // legacy
  imagePrompt?: string; // deprecated; kept for migration

  // new fields
  imageSpec?: ImageSpec;
  renderedImagePrompt?: string;
}
```

Backward compatibility: existing decks may only have `imagePrompt`. We will keep a fallback path for them.

---

## 5. Schema Changes (Structured Output)

### 5.1 New `imageSpec` Schema Fragment

In `generateSlidesFromDocument`, define `imageSpecSchema` and plug it into `slidesSchema.items.properties`:

```ts
const imageSpecSchema = {
  type: "object",
  properties: {
    primaryFocal: { type: "string" },
    subjects: {
      type: "array",
      items: { type: "string" },
      minItems: 2,
      maxItems: 5,
    },
    actions: {
      type: "array",
      items: { type: "string" },
      minItems: 0,
      maxItems: 3,
    },
    mustInclude: {
      type: "array",
      items: { type: "string" },
      minItems: 2,
      maxItems: 6,
    },
    avoid: {
      type: "array",
      items: { type: "string" },
      minItems: 2,
      maxItems: 10,
    },
    composition: {
      type: "object",
      properties: {
        layout: {
          type: "string",
          enum: [
            "single-focal-subject-centered",
            "balanced-pair",
            "simple-sequence-2-panel",
          ],
        },
        viewpoint: {
          type: "string",
          enum: [
            "front",
            "three-quarter",
            "side",
            "overhead",
            "child-eye-level",
          ],
        },
        whitespace: {
          type: "string",
          enum: ["generous", "moderate"],
        },
      },
      required: ["layout", "viewpoint", "whitespace"],
    },
    textPolicy: {
      type: "string",
      enum: ["NO_LABELS", "LIMITED_LABELS_1_TO_3"],
    },
    allowedLabels: {
      type: "array",
      items: { type: "string" },
      minItems: 0,
      maxItems: 3,
    },
    colors: {
      type: "array",
      items: { type: "string" },
      minItems: 0,
      maxItems: 5,
    },
    negativePrompt: {
      type: "array",
      items: { type: "string" },
      minItems: 0,
      maxItems: 10,
    },
  },
  required: [
    "primaryFocal",
    "subjects",
    "mustInclude",
    "avoid",
    "composition",
    "textPolicy",
  ],
};
```

Then modify `slidesSchema`:

```ts
const slidesSchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      title: { type: "string" },
      content: {
        type: "array",
        items: { type: "string" },
      },
      layout: {
        type: "string",
        enum: ["Title Slide", "Content"],
      },
      // REPLACE THIS:
      // imagePrompt: { type: "string" },
      // WITH THIS:
      imageSpec: imageSpecSchema,
      speakerNotes: { type: "string", ... },
      sources: { ... },
    },
    required: [
      "title",
      "content",
      "layout",
      "imageSpec",
      "speakerNotes",
    ],
  },
};
```

### 5.2 Validation Changes

Update `validateSlideStructure`:

- Replace checks that require `imagePrompt` with checks that require `imageSpec`.
- Optionally, for legacy data, if `imageSpec` is missing but `imagePrompt` exists, push a warning instead of failing.

```ts
const required = ['title', 'content', 'layout', 'imageSpec', 'speakerNotes'];
```

---

## 6. Prompt Instruction Changes (Slide Generation)

### 6.1 Replace IMAGE PROMPTING GUIDELINES

Currently, the prompt asks the model to write `imagePrompt` as a freeform description string. Replace that section with instructions to output a JSON `imageSpec` object that conforms to the schema.

Add to the main prompt in `generateSlidesFromDocument`:

```text
IMAGE VISUAL SPECIFICATION (imageSpec)
You must output an `imageSpec` object for each content slide. This object will be converted into an AI image generation prompt.

imageSpec rules:
- The image is a supplemental visual aid for the slide, not the entire lesson.
- Illustrate EXACTLY ONE primary idea from the slide bullets.
- Keep the scene simple and uncluttered.
- Use 2–5 concrete subjects (things you can literally draw).
- Use 2–6 mustInclude elements that are essential to understanding the slide.
- Use the avoid list to exclude distracting or confusing elements.
- Composition:
  - Prefer layout = "single-focal-subject-centered".
  - Viewpoint should be age-appropriate: younger grades use "child-eye-level" or "front".
  - Whitespace should usually be "generous" so teachers can place text on top.
- Text policy:
  - Default: textPolicy = "NO_LABELS" (no text or labels in the image).
  - Only when the slide clearly needs 1–3 simple labels (e.g., parts of a plant), use textPolicy = "LIMITED_LABELS_1_TO_3" and specify allowedLabels.
- Colors: choose 3–5 high-contrast, classroom-friendly colors.
- negativePrompt: list common failure modes to avoid (e.g., "no cluttered background", "no chemical equations", "no complex diagrams").

Output a valid JSON object for imageSpec matching the schema. Do NOT output an image prompt paragraph.
```

Ensure this appears clearly in the instructions that describe the JSON output structure.

---

## 7. Deterministic Prompt Formatter

### 7.1 New Utility: `formatImageSpec`

Create `lib/imagePrompt.ts` (or inside `gemini.ts` if preferred):

```ts
import type { ImageSpec } from '../types';

interface FormatContext {
  gradeLevel: string;  // "2nd", "5th", etc.
  subject: string;     // "Science", "Math", etc.
}

export function formatImageSpec(spec: ImageSpec, ctx: FormatContext): string {
  const {
    primaryFocal,
    subjects,
    actions = [],
    mustInclude,
    avoid,
    composition,
    textPolicy,
    allowedLabels = [],
    colors = [],
    negativePrompt = [],
  } = spec;

  const actionsStr = actions.length
    ? `Actions: ${actions.join(', ')}.`
    : '';

  const colorsStr = colors.length
    ? `Primary colors: ${colors.join(', ')}.`
    : '';

  const textPolicyStr =
    textPolicy === 'NO_LABELS'
      ? 'No text, letters, or labels in the image.'
      : allowedLabels.length > 0
        ? `Include at most these labels: ${allowedLabels.join(', ')}. Labels must be simple, legible, and large.`
        : 'At most 1–3 simple labels if absolutely needed for clarity.';

  const avoidList = [
    ...avoid,
    ...negativePrompt,
    'watermarks or signatures in the focal area',
    'dense, distracting background patterns',
    'tiny unreadable details',
  ];

  return `EDUCATIONAL VISUAL AID PROMPT
Audience: ${ctx.gradeLevel} grade
Subject: ${ctx.subject}

Primary focus:
${primaryFocal}

Show:
- ${mustInclude.join('\n- ')}

Objects:
- ${subjects.join('\n- ')}

Composition:
- Layout: ${composition.layout}
- Viewpoint: ${composition.viewpoint}
- Background: plain white
- Whitespace: ${composition.whitespace} (leave room for slide text)

Text in image:
- ${textPolicyStr}

Style:
- Flat vector educational illustration, clean lines, classroom-friendly
- High contrast, simple shapes, no photorealism

${colorsStr}

Avoid:
- ${avoidList.join('\n- ')}
`;
}
```

### 7.2 Integration in Slide Generation Flow

After parsing slides from Gemini in `generateSlidesFromDocument`, do:

```ts
import { formatImageSpec } from '../lib/imagePrompt';

slides.forEach((slide) => {
  if (slide.imageSpec) {
    // Optionally: validate and sanitize spec first
    // slide.imageSpec = sanitizeImageSpec(slide.imageSpec, gradeLevel);

    slide.renderedImagePrompt = formatImageSpec(slide.imageSpec, {
      gradeLevel,
      subject,
    });
  }
});
```

This ensures every slide has a stable `renderedImagePrompt` used for UI and image generation.

---

## 8. Image Generation API Refactor

### 8.1 New Signature: `generateImageFromSpec`

Replace the old `generateImage` with a new function that accepts an `ImageSpec` and context:

```ts
import type { ImageSpec } from '../types';
import { formatImageSpec } from '../lib/imagePrompt';

interface ImageGenOptions {
  temperature?: number;
  aspectRatio?: '16:9' | '1:1';
  imageSize?: '1K' | '2K' | '4K';
}

export const generateImageFromSpec = async (
  spec: ImageSpec,
  gradeLevel: string,
  subject: string,
  {
    temperature = 0.3,
    aspectRatio = '16:9',
    imageSize = '2K',
  }: ImageGenOptions = {}
): Promise<{ blob: Blob; renderedPrompt: string }> => {
  try {
    const renderedPrompt = formatImageSpec(spec, { gradeLevel, subject });

    const response = await retryWithBackoff(() =>
      ai.models.generateContent({
        model: 'gemini-3-pro-image-preview',
        contents: renderedPrompt,
        config: {
          temperature,
          responseModalities: ['TEXT', 'IMAGE'],
          imageConfig: {
            aspectRatio,
            imageSize,
          },
        } as any,
      })
    );

    const candidatesParts = (response as any).candidates?.[0]?.content?.parts;
    const parts = candidatesParts || (response as any).parts || [];

    if (parts && parts.length > 0) {
      const validPart = parts.find((p: any) => p.inlineData || p.inline_data);

      if (validPart) {
        const inlineData = validPart.inlineData || validPart.inline_data;
        if (inlineData) {
          const base64Data = inlineData.data;
          const mimeType = inlineData.mimeType || inlineData.mime_type || 'image/png';

          if (!mimeType.startsWith('image/')) {
            throw new Error(`Invalid image mimeType received: ${mimeType}`);
          }

          let bytes: Uint8Array;
          if (typeof (globalThis as any).Buffer !== 'undefined') {
            bytes = (globalThis as any).Buffer.from(base64Data, 'base64');
          } else {
            const binaryString = atob(base64Data);
            bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
          }

          return {
            blob: new Blob([bytes as any], { type: mimeType }),
            renderedPrompt,
          };
        }
      }
    }

    console.error('Response structure:', JSON.stringify(response, null, 2));
    throw new Error('No image data found in response');
  } catch (error) {
    console.error('Error generating image with Gemini API:', error);
    throw new Error('Failed to generate image. Please try again.');
  }
};
```

### 8.2 Call Site Changes

Any place that currently calls:

```ts
generateImage(slide.imagePrompt, gradeLevel, temperature, aspectRatio)
```

Should become:

```ts
if (!slide.imageSpec) {
  throw new Error('Missing imageSpec for slide');
}

const { blob, renderedPrompt } = await generateImageFromSpec(
  slide.imageSpec,
  gradeLevel,
  subject,
  { temperature, aspectRatio }
);

slide.renderedImagePrompt = renderedPrompt;
// Store blob in Firebase Storage, update slide metadata, etc.
```

---

## 9. ImageSpec Validation & Sanitization

### 9.1 Utility: `validateImageSpec`

Add a runtime validator to catch malformed specs:

```ts
export function validateImageSpec(spec: ImageSpec): string[] {
  const errors: string[] = [];

  if (!spec.primaryFocal) {
    errors.push('imageSpec.primaryFocal is required');
  }

  if (!spec.subjects || spec.subjects.length < 2 || spec.subjects.length > 5) {
    errors.push('imageSpec.subjects must have 2–5 items');
  }

  if (!spec.mustInclude || spec.mustInclude.length < 2 || spec.mustInclude.length > 6) {
    errors.push('imageSpec.mustInclude must have 2–6 items');
  }

  if (!spec.avoid || spec.avoid.length < 2) {
    errors.push('imageSpec.avoid must have at least 2 items');
  }

  if (!spec.composition) {
    errors.push('imageSpec.composition is required');
  }

  return errors;
}
```

### 9.2 Utility: `sanitizeImageSpec`

Coerce minor issues and set defaults:

```ts
export function sanitizeImageSpec(spec: ImageSpec, gradeLevel: string): ImageSpec {
  const clone: ImageSpec = { ...spec };

  // Clamp array sizes
  clone.subjects = (clone.subjects || []).slice(0, 5);
  clone.mustInclude = (clone.mustInclude || []).slice(0, 6);
  clone.avoid = (clone.avoid || []).slice(0, 10);

  // Defaults
  clone.composition = clone.composition || {
    layout: 'single-focal-subject-centered',
    viewpoint: 'front',
    whitespace: 'generous',
  };

  if (!clone.composition.layout) clone.composition.layout = 'single-focal-subject-centered';
  if (!clone.composition.whitespace) clone.composition.whitespace = 'generous';

  // Grade-level viewpoint hints (simple heuristic)
  const gradeNum = parseInt(gradeLevel, 10); // e.g., "2nd" → NaN, adjust if needed
  if (!clone.composition.viewpoint) {
    clone.composition.viewpoint = 'front';
  }

  // Text policy
  if (!clone.textPolicy) {
    clone.textPolicy = 'NO_LABELS';
  }

  if (clone.textPolicy === 'NO_LABELS') {
    clone.allowedLabels = [];
  } else if (clone.allowedLabels) {
    clone.allowedLabels = clone.allowedLabels.slice(0, 3);
  }

  return clone;
}
```

Integrate this into the slide post-processing loop in `generateSlidesFromDocument`.

---

## 10. Regeneration Strategy

### 10.1 Current Behavior

- `regenerateImagePrompt()` creates a new freeform prompt string via a Gemini 2.5 Pro call.

### 10.2 New Behavior

We want three modes:

1. **Regenerate Image (Same Spec)**
   - Reuse existing `imageSpec` and `renderedImagePrompt`.
   - Just call `generateImageFromSpec()` again (temperature controls variation).
   - No changes to spec; no extra text calls.

2. **Regenerate Prompt Wording (Same Spec)**
   - Optionally support multiple formatting templates.
   - Call `formatImageSpec()` with a different template variant (no API call).
   - Semantics remain identical; purely wording.

3. **New Visual Idea (New Spec)**
   - Replace `regenerateImagePrompt` with `regenerateImageSpec` using structured output.

### 10.3 New Function: `regenerateImageSpec`

```ts
import { ImageSpec } from '../types';

export const regenerateImageSpec = async (
  slideTitle: string,
  slideContent: string[],
  gradeLevel: string,
  subject: string,
  temperature: number = 0.5
): Promise<ImageSpec> => {
  const prompt = `
    You are an expert educational content creator.
    Generate a JSON imageSpec object for an educational illustration that visually explains this slide.

    SLIDE CONTEXT
    Title: "${slideTitle}"
    Content: ${slideContent.join('; ')}
    Target Audience: ${gradeLevel} Grade Students
    Subject: "${subject}"

    Follow the imageSpec schema closely and ensure:
    - One clear primaryFocal idea.
    - 2–5 concrete subjects.
    - 2–6 mustInclude items.
    - At least 2 avoid items to prevent clutter.
    - layout is usually "single-focal-subject-centered".
    - whitespace is "generous" for slide text.
    - textPolicy is usually "NO_LABELS" unless labels are needed for understanding.

    Output ONLY the JSON object for imageSpec, no comments or explanation.
  `;

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-pro',
    contents: prompt,
    config: {
      temperature,
      responseMimeType: 'application/json',
      responseSchema: imageSpecSchema,
    } as any,
  });

  return JSON.parse(response.text) as ImageSpec;
};
```

Integrate this into the UI as “New Visual Idea” or “Regenerate Spec”.

---

## 11. Storage & Backend

### 11.1 Firestore / Database

Per slide document, persist:

- `imageSpec: ImageSpec`
- `renderedImagePrompt: string`
- Optionally: `lastImageGenSettings` (temperature, aspectRatio, imageSize)

Per deck, persist:

- `defaultImageSettings`:
  - `aspectRatio` (default `'16:9'`)
  - `imageSize` (default `'2K'`)
  - `temperature` (default `0.3`)

### 11.2 Firebase Storage

For each generated image, store:

- Blob under path `decks/{deckId}/slides/{slideId}/images/{hash}.png`
- Metadata:
  - `model: 'gemini-3-pro-image-preview'`
  - `aspectRatio`
  - `imageSize`
  - `temperature`
  - `promptHash` (hash of `renderedImagePrompt`)

---

## 12. Migration Plan

### Phase 1 – Non-breaking

- Extend types and schema to support `imageSpec` + `renderedImagePrompt` while keeping `imagePrompt` optional.
- For new decks:
  - Use `imageSpec` flow.
- For old decks:
  - If `imageSpec` is missing but `imagePrompt` exists, keep using old `generateImage(prompt, ...)` function or add a small adapter.

### Phase 2 – Promotion

- Default all new slide generation to `imageSpec`.
- Deprecate `imagePrompt` in UI (hide it, but keep in data).
- Enable the new image pipeline by default.

### Phase 3 – Optional Conversion

- Add a background or on-demand "Convert to new imageSpec" for legacy slides:
  - Use a Gemini call (one per slide or batch) to transform legacy `imagePrompt` into `imageSpec` via structured output.
  - Store `imageSpec` + `renderedImagePrompt`.
  - After coverage is high enough, drop dependence on legacy `imagePrompt` in code paths.

---

## 13. Acceptance Criteria

- New slide generations produce `imageSpec` objects per content slide.
- `renderedImagePrompt` is deterministically generated from `imageSpec` and visible in the UI.
- `generateImageFromSpec()` uses:
  - `model: 'gemini-3-pro-image-preview'`
  - `responseModalities: ['TEXT', 'IMAGE']`
  - `imageConfig: { aspectRatio, imageSize }`
- Default image config is `aspectRatio='16:9'`, `imageSize='2K'`, `temperature≈0.3`.
- Images are visually:
  - Flat, vector-style; white background
  - Single, clear focal subject
  - Generous whitespace
  - No or minimal labels (and only if explicitly allowed by `textPolicy`)
- No additional Gemini API calls are required in the baseline flow beyond:
  - Slide generation (text)
  - Image generation (image)
- Optional “New Visual Idea” regeneration creates a new `imageSpec` via a Gemini call and re-renders the prompt.

---

## 14. Implementation Checklist (Cursor)

- [ ] Add `ImageSpec` types and update `Slide` type.
- [ ] Add `imageSpecSchema` and integrate into `slidesSchema`.
- [ ] Update slide generation prompt to request `imageSpec` JSON.
- [ ] Implement `validateImageSpec` and `sanitizeImageSpec`.
- [ ] Implement `formatImageSpec` and wire it into `generateSlidesFromDocument`.
- [ ] Refactor `generateImage` → `generateImageFromSpec` and update Gemini 3 Image config (`responseModalities`, `imageConfig`).
- [ ] Update all call sites to use `imageSpec` + `generateImageFromSpec` for new decks.
- [ ] Implement `regenerateImageSpec` for "New Visual Idea".
- [ ] Wire UI to display `renderedImagePrompt` and support regeneration modes.
- [ ] Add telemetry/logging for image failures and spec validation errors.
