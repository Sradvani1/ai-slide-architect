
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // User Projects
    match /users/{userId}/projects/{projectId} {
      // 1. Explicit Read Access (Owner only)
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // 2. Delete Access (Owner only)
      allow delete: if request.auth != null && request.auth.uid == userId;

      // Project Validation Function
      function isValidProject() {
         let data = request.resource.data;
         // DENY forbidden legacy fields and root slides array
         return !data.keys().hasAny(['slides', 'imagePrompt', 'prompts', 'legacy'])
             // REQUIRE essential metadata fields
             && data.keys().hasAll(['title', 'updatedAt', 'userId'])
             // ALLOW new status fields (optional)
             && (!data.keys().hasAny(['status']) || data.status in ['generating', 'completed', 'failed'])
             && (!data.keys().hasAny(['generationProgress']) || (data.generationProgress is int && data.generationProgress >= 0 && data.generationProgress <= 100));
      }
      
      // 3. Create & Update (Owner + Validation)
      allow create: if request.auth != null && request.auth.uid == userId && isValidProject();
      allow update: if request.auth != null && request.auth.uid == userId && isValidProject();

      // Subcollection: Slides
      match /slides/{slideId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && request.auth.uid == userId;
        
        // Slide Validation Function
        function isValidSlide() {
           let data = request.resource.data;
           // DENY legacy fields
           return !data.keys().hasAny(['imagePrompt', 'prompts'])
               // REQUIRE essential content fields
               && data.keys().hasAll(['id', 'title', 'content', 'sortOrder'])
               // VALIDATE prompt generation state if present
               && (!data.keys().hasAny(['promptGenerationState']) || 
                   data.promptGenerationState in ['pending', 'queued', 'generating', 'partial', 'completed', 'failed'])
               && (!data.keys().hasAny(['promptGenerationAttempts']) || 
                   data.promptGenerationAttempts is int && data.promptGenerationAttempts >= 0)
               // VALIDATE promptHistory if present (Must be list)
               && (!data.keys().hasAny(['promptHistory']) || data.promptHistory is list);
        }
        
        allow create: if request.auth != null && request.auth.uid == userId && isValidSlide();
        allow update: if request.auth != null && request.auth.uid == userId && isValidSlide();
      }
    }
    
    // User Profile
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Prompt Generation Queue
    match /promptGenerationQueue/{queueId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      allow write: if false; // Only backend/triggers can write
    }

    // Failed Prompt Generation Queue
    match /failedPromptGenerationQueue/{queueId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      allow write: if false; // Only backend/triggers can write
    }

    // Model Pricing (Internal reference)
    match /modelPricing/{modelId} {
      allow read: if request.auth != null;
      allow write: if false; // Only admin/backend can write
    }
  }
}
