# SlidesEdu Image Generation Refactor – Complete Specification

**Status:** Development Refactor (No Backward Compatibility Required)  
**Date:** December 15, 2025  
**Scope:** Full ImageSpec pipeline upgrade to support pedagogically-driven image generation  
**Target Outcome:** Images are teaching aids, not decorative—clear, concept-focused, curriculum-agnostic

---

## Executive Summary

The current image generation pipeline produces generic, simplistic images. The refactor implements a **three-layer teaching-focused specification** (conceptual purpose → structured spec → formatted prompt) that forces the model to think pedagogically.

**Key Changes:**
1. Add `conceptualPurpose` field to make teaching intent explicit
2. Expand composition enums (layouts and viewpoints) for better visual guidance
3. Tighten numeric ranges (subjects, mustInclude, colors, etc.) for consistency
4. Refactor `formatImageSpec()` to lead with teaching purpose
5. Update validators and sanitizers to enforce new constraints
6. Update all schemas (types, structured output, validation)

**No backward compatibility required.** All test projects will be regenerated.

---

## SECTION 1: TYPE DEFINITIONS (`types.ts`)

### 1.1 Update ImageLayout Enum

**Current:**
```typescript
export type ImageLayout =
  | 'single-focal-subject-centered'
  | 'balanced-pair'
  | 'simple-sequence-2-panel';
```

**New (ADD the following layouts):**
```typescript
export type ImageLayout =
  | 'single-focal-subject-centered'
  | 'balanced-pair'
  | 'simple-sequence-2-panel'
  | 'comparison-split-screen'
  | 'diagram-with-flow';
```

**Rationale:** These new layouts enable:
- `comparison-split-screen`: Before/after, cause/effect, competing concepts (e.g., segregation vs. integration, reactants vs. products)
- `diagram-with-flow`: Cycles, processes, energy transfer, information flow (e.g., water cycle, photosynthesis, ecosystems)

---

### 1.2 Update Viewpoint Enum

**Current:**
```typescript
export type Viewpoint =
  | 'front'
  | 'three-quarter'
  | 'side'
  | 'overhead'
  | 'child-eye-level';
```

**New (ADD the following viewpoints):**
```typescript
export type Viewpoint =
  | 'front'
  | 'three-quarter'
  | 'side'
  | 'overhead'
  | 'child-eye-level'
  | 'side-profile'
  | 'isometric-3d-cutaway';
```

**Rationale:**
- `side-profile`: Shows processes, sequences, internal structure (e.g., water cycle side view, RNN bottleneck)
- `isometric-3d-cutaway`: Shows internal layers and structure clearly (e.g., cell anatomy, atomic structure, building cross-sections)

---

### 1.3 Add conceptualPurpose to ImageSpec

**Current:**
```typescript
export interface ImageSpec {
  primaryFocal: string;
  subjects: string[];
  actions?: string[];
  mustInclude: string[];
  avoid: string[];
  composition: { layout: ImageLayout; viewpoint: Viewpoint; whitespace: Whitespace; };
  textPolicy: ImageTextPolicy;
  allowedLabels?: string[];
  colors?: string[];
  negativePrompt?: string[];
}
```

**New (INSERT after primaryFocal):**
```typescript
export interface ImageSpec {
  // WHAT: semantic content
  primaryFocal: string;
  
  // WHY (NEW): What understanding or insight should students gain?
  conceptualPurpose: string; // REQUIRED – e.g., "Show that energy is lost at each trophic level"
  
  subjects: string[];
  actions?: string[];
  mustInclude: string[];
  avoid: string[];
  
  // HOW: composition & layout
  composition: {
    layout: ImageLayout;
    viewpoint: Viewpoint;
    whitespace: Whitespace;
  };

  // TEXT in the image
  textPolicy: ImageTextPolicy;
  allowedLabels?: string[];

  // Palette
  colors?: string[];

  // Additional negative constraints
  negativePrompt?: string[];
}
```

**Note:** `conceptualPurpose` is **required**, not optional. This is the teaching intent lever.

---

## SECTION 2: VALIDATION (`imageUtils.ts` – validateImageSpec)

Replace the entire `validateImageSpec()` function with this version:

```typescript
/**
 * Validates an ImageSpec object at runtime.
 * Returns an array of error messages. Empty array means valid.
 * No backward compatibility—all specs must be complete and well-formed.
 */
export function validateImageSpec(spec: ImageSpec): string[] {
  const errors: string[] = [];

  if (!spec) {
    return ['ImageSpec is null or undefined'];
  }

  // ========== REQUIRED FIELDS ==========

  // primaryFocal
  if (!spec.primaryFocal || typeof spec.primaryFocal !== 'string' || spec.primaryFocal.trim() === '') {
    errors.push('imageSpec.primaryFocal is required and must be non-empty');
  } else if (spec.primaryFocal.length < 10) {
    errors.push('imageSpec.primaryFocal must be at least 10 characters (too vague otherwise)');
  }

  // conceptualPurpose (NEW – REQUIRED)
  if (!spec.conceptualPurpose || typeof spec.conceptualPurpose !== 'string' || spec.conceptualPurpose.trim() === '') {
    errors.push('imageSpec.conceptualPurpose is required and must be non-empty');
  } else if (spec.conceptualPurpose.length < 15) {
    errors.push('imageSpec.conceptualPurpose must be at least 15 characters (state the teaching intent clearly)');
  }

  // subjects (tightened range)
  if (!Array.isArray(spec.subjects) || spec.subjects.length < 3 || spec.subjects.length > 6) {
    errors.push('imageSpec.subjects must have 3–6 items (concrete visual elements)');
  } else {
    spec.subjects.forEach((s, i) => {
      if (!s || typeof s !== 'string' || s.trim() === '') {
        errors.push(`imageSpec.subjects[${i}] is empty or invalid`);
      }
    });
  }

  // mustInclude (tightened range)
  if (!Array.isArray(spec.mustInclude) || spec.mustInclude.length < 3 || spec.mustInclude.length > 5) {
    errors.push('imageSpec.mustInclude must have 3–5 items (essential visual details)');
  } else {
    spec.mustInclude.forEach((m, i) => {
      if (!m || typeof m !== 'string' || m.trim() === '') {
        errors.push(`imageSpec.mustInclude[${i}] is empty or invalid`);
      }
    });
  }

  // avoid
  if (!Array.isArray(spec.avoid) || spec.avoid.length < 2) {
    errors.push('imageSpec.avoid must have at least 2 items (common confusers to exclude)');
  } else {
    spec.avoid.forEach((a, i) => {
      if (!a || typeof a !== 'string' || a.trim() === '') {
        errors.push(`imageSpec.avoid[${i}] is empty or invalid`);
      }
    });
  }

  // ========== COMPOSITION VALIDATION ==========

  if (!spec.composition) {
    errors.push('imageSpec.composition is required');
  } else {
    // Valid layouts (including new ones)
    const validLayouts: ImageLayout[] = [
      'single-focal-subject-centered',
      'balanced-pair',
      'simple-sequence-2-panel',
      'comparison-split-screen',
      'diagram-with-flow',
    ];
    if (!spec.composition.layout || !validLayouts.includes(spec.composition.layout)) {
      errors.push(`Invalid layout: "${spec.composition.layout}". Must be one of: ${validLayouts.join(', ')}`);
    }

    // Valid viewpoints (including new ones)
    const validViewpoints: Viewpoint[] = [
      'front',
      'three-quarter',
      'side',
      'overhead',
      'child-eye-level',
      'side-profile',
      'isometric-3d-cutaway',
    ];
    if (!spec.composition.viewpoint || !validViewpoints.includes(spec.composition.viewpoint)) {
      errors.push(`Invalid viewpoint: "${spec.composition.viewpoint}". Must be one of: ${validViewpoints.join(', ')}`);
    }

    // Valid whitespace
    const validWhitespaces: Whitespace[] = ['generous', 'moderate'];
    if (!spec.composition.whitespace || !validWhitespaces.includes(spec.composition.whitespace)) {
      errors.push(`Invalid whitespace: "${spec.composition.whitespace}". Must be one of: ${validWhitespaces.join(', ')}`);
    }
  }

  // ========== TEXT POLICY VALIDATION ==========

  if (spec.textPolicy) {
    const validPolicies: ImageTextPolicy[] = ['NO_LABELS', 'LIMITED_LABELS_1_TO_3'];
    if (!validPolicies.includes(spec.textPolicy)) {
      errors.push(`Invalid textPolicy: "${spec.textPolicy}". Must be NO_LABELS or LIMITED_LABELS_1_TO_3`);
    }

    // If LIMITED_LABELS, allowedLabels must be present and 1–3 items
    if (spec.textPolicy === 'LIMITED_LABELS_1_TO_3') {
      if (!Array.isArray(spec.allowedLabels) || spec.allowedLabels.length < 1 || spec.allowedLabels.length > 3) {
        errors.push('imageSpec.allowedLabels must have 1–3 items when textPolicy is LIMITED_LABELS_1_TO_3');
      }
    }
  } else {
    errors.push('imageSpec.textPolicy is required');
  }

  // ========== OPTIONAL ARRAY VALIDATION ==========

  // colors (optional, but if present should be 3–5)
  if (spec.colors && Array.isArray(spec.colors)) {
    if (spec.colors.length < 3 || spec.colors.length > 5) {
      errors.push('imageSpec.colors must have 3–5 items (if provided)');
    }
  }

  // negativePrompt (optional, but if present should be 3–5)
  if (spec.negativePrompt && Array.isArray(spec.negativePrompt)) {
    if (spec.negativePrompt.length < 3 || spec.negativePrompt.length > 5) {
      errors.push('imageSpec.negativePrompt must have 3–5 items (if provided)');
    }
  }

  // actions (optional, max 3)
  if (spec.actions && Array.isArray(spec.actions) && spec.actions.length > 3) {
    errors.push('imageSpec.actions must have at most 3 items');
  }

  return errors;
}
```

---

## SECTION 3: SANITIZATION (`imageUtils.ts` – sanitizeImageSpec)

Replace the entire `sanitizeImageSpec()` function:

```typescript
/**
 * Sanitizes an ImageSpec, ensuring all arrays are normalized to ranges
 * and all required fields have sensible defaults.
 * This should be called immediately after Gemini returns a spec.
 */
export function sanitizeImageSpec(spec: ImageSpec, gradeLevel: string): ImageSpec {
  // 1. Shallow clone
  const clone: ImageSpec = { ...spec };

  // 2. Normalize arrays to target ranges
  clone.subjects = (Array.isArray(spec.subjects) ? spec.subjects : [])
    .filter(s => s && typeof s === 'string')
    .slice(0, 6); // Max 6

  clone.mustInclude = (Array.isArray(spec.mustInclude) ? spec.mustInclude : [])
    .filter(m => m && typeof m === 'string')
    .slice(0, 5); // Max 5

  clone.avoid = (Array.isArray(spec.avoid) ? spec.avoid : [])
    .filter(a => a && typeof a === 'string')
    .slice(0, 10); // Keep a reasonable upper bound

  clone.actions = (Array.isArray(spec.actions) ? spec.actions : [])
    .filter(a => a && typeof a === 'string')
    .slice(0, 3); // Max 3

  clone.colors = (Array.isArray(spec.colors) ? spec.colors : [])
    .filter(c => c && typeof c === 'string')
    .slice(0, 5); // Max 5

  clone.negativePrompt = (Array.isArray(spec.negativePrompt) ? spec.negativePrompt : [])
    .filter(n => n && typeof n === 'string')
    .slice(0, 5); // Max 5

  clone.allowedLabels = (Array.isArray(spec.allowedLabels) ? spec.allowedLabels : [])
    .filter(l => l && typeof l === 'string')
    .slice(0, 3); // Max 3

  // 3. Composition
  clone.composition = spec.composition ? { ...spec.composition } : {
    layout: 'single-focal-subject-centered',
    viewpoint: 'front',
    whitespace: 'generous',
  };

  // 4. Smart defaults for Composition fields
  const validLayouts: ImageLayout[] = [
    'single-focal-subject-centered',
    'balanced-pair',
    'simple-sequence-2-panel',
    'comparison-split-screen',
    'diagram-with-flow',
  ];
  if (!clone.composition.layout || !validLayouts.includes(clone.composition.layout)) {
    clone.composition.layout = 'single-focal-subject-centered';
  }

  const validViewpoints: Viewpoint[] = [
    'front',
    'three-quarter',
    'side',
    'overhead',
    'child-eye-level',
    'side-profile',
    'isometric-3d-cutaway',
  ];
  if (!clone.composition.viewpoint || !validViewpoints.includes(clone.composition.viewpoint)) {
    // Grade-aware viewpoint default
    const gradeNum = parseGradeLevel(gradeLevel);
    clone.composition.viewpoint = gradeNum <= 8 ? 'front' : 'front'; // High school also prefers clear front views
  }

  const validWhitespaces: Whitespace[] = ['generous', 'moderate'];
  if (!clone.composition.whitespace || !validWhitespaces.includes(clone.composition.whitespace)) {
    clone.composition.whitespace = 'generous';
  }

  // 5. Text Policy defaults
  if (!clone.textPolicy) {
    clone.textPolicy = 'NO_LABELS';
  }

  if (clone.textPolicy === 'NO_LABELS') {
    clone.allowedLabels = [];
  } else if (clone.textPolicy === 'LIMITED_LABELS_1_TO_3' && (!clone.allowedLabels || clone.allowedLabels.length === 0)) {
    // If LIMITED_LABELS but no allowedLabels provided, set a default warning
    clone.allowedLabels = [];
  }

  // 6. Ensure required fields exist (backfill if missing, though validation should have caught this)
  if (!clone.primaryFocal || clone.primaryFocal.trim() === '') {
    clone.primaryFocal = 'Visual representation of the slide concept';
  }

  if (!clone.conceptualPurpose || clone.conceptualPurpose.trim() === '') {
    clone.conceptualPurpose = `Help students understand: ${clone.primaryFocal}`;
  }

  // 7. Ensure color defaults
  if (!clone.colors || clone.colors.length === 0) {
    clone.colors = [
      '#1976D2 (primary blue)',
      '#4CAF50 (accent green)',
      '#FF9800 (highlight orange)',
      '#F5F5F5 (light background)',
    ];
  }

  // 8. Ensure negativePrompt defaults
  if (!clone.negativePrompt || clone.negativePrompt.length === 0) {
    clone.negativePrompt = [
      'unclear or ambiguous composition',
      'background too busy or cluttered',
      'missing key visual elements',
      'colors that blend or lack contrast',
      'text or labels not in allowedLabels',
    ];
  }

  return clone;
}
```

---

## SECTION 4: FORMATTER (`imageUtils.ts` – formatImageSpec)

Replace the entire `formatImageSpec()` function:

```typescript
interface FormatContext {
  gradeLevel: string;
  subject: string;
}

/**
 * Deterministically formats an ImageSpec into a detailed prompt string for Gemini image generation.
 * CRITICAL: This function embeds the teaching purpose early so the model understands "why" this image matters.
 */
export function formatImageSpec(spec: ImageSpec, ctx: FormatContext): string {
  const {
    primaryFocal,
    conceptualPurpose,
    subjects,
    actions = [],
    mustInclude,
    avoid,
    composition,
    textPolicy,
    allowedLabels = [],
    colors = [],
    negativePrompt = [],
  } = spec;

  let prompt = `EDUCATIONAL VISUAL AID PROMPT\n`;
  prompt += `${'='.repeat(50)}\n\n`;

  // ========== CONTEXT ==========
  prompt += `CONTEXT:\n`;
  prompt += `- Grade Level: ${ctx.gradeLevel}\n`;
  prompt += `- Subject: ${ctx.subject}\n\n`;

  // ========== TEACHING PURPOSE (KEY DRIVER) ==========
  prompt += `TEACHING PURPOSE (Why this image matters):\n`;
  prompt += `${conceptualPurpose}\n\n`;

  // ========== PRIMARY CONCEPT ==========
  prompt += `PRIMARY VISUAL CONCEPT:\n`;
  prompt += `${primaryFocal}\n\n`;

  // ========== VISUAL ELEMENTS ==========
  prompt += `VISUAL ELEMENTS (Concrete objects and subjects to include):\n`;
  subjects.forEach((s, i) => prompt += `${i + 1}. ${s}\n`);
  prompt += '\n';

  // ========== ACTIONS (if any) ==========
  if (actions.length > 0) {
    prompt += `ACTIONS/INTERACTIONS (Movements or relationships between elements):\n`;
    actions.forEach((a, i) => prompt += `${i + 1}. ${a}\n`);
    prompt += '\n';
  }

  // ========== MUST INCLUDE ==========
  prompt += `MUST INCLUDE (Critical visual details for understanding):\n`;
  mustInclude.forEach((m, i) => prompt += `${i + 1}. ${m}\n`);
  prompt += '\n';

  // ========== COMPOSITION ==========
  prompt += `COMPOSITION & LAYOUT:\n`;
  prompt += `- Layout Style: ${composition.layout}\n`;
  prompt += `- Viewpoint: ${composition.viewpoint}\n`;
  prompt += `- Whitespace: ${composition.whitespace} (leave room for slide text/annotations)\n\n`;

  // ========== TEXT POLICY ==========
  prompt += `TEXT POLICY:\n`;
  if (textPolicy === 'NO_LABELS') {
    prompt += `- No text, labels, or lettering in the image.\n`;
    prompt += `- Teachers/presenters will add labels and annotations on the slide itself.\n`;
  } else if (textPolicy === 'LIMITED_LABELS_1_TO_3' && allowedLabels.length > 0) {
    prompt += `- Include ONLY these ${allowedLabels.length} label(s), no more:\n`;
    allowedLabels.forEach((l, i) => prompt += `  ${i + 1}. "${l}"\n`);
    prompt += `- Labels must be large, legible, centered, and use the primary colors.\n`;
  }
  prompt += '\n';

  // ========== COLORS (Semantic) ==========
  prompt += `COLORS (Semantically meaningful, high-contrast):\n`;
  prompt += `- Use these ${colors.length} colors consistently throughout:\n`;
  colors.forEach((c, i) => prompt += `  ${i + 1}. ${c}\n`);
  prompt += `- Ensure high contrast between foreground and background.\n`;
  prompt += `- Use color to encode meaning (e.g., red = active/important, blue = structure, green = growth).\n\n`;

  // ========== AVOID ==========
  prompt += `AVOID (Things that would confuse or distract):\n`;
  avoid.forEach((a, i) => prompt += `${i + 1}. ${a}\n`);
  prompt += '\n';

  // ========== NEGATIVE PROMPT (Gemini-specific) ==========
  prompt += `NEGATIVE PROMPT (Prevent common failure modes):\n`;
  negativePrompt.forEach((n, i) => prompt += `${i + 1}. ${n}\n`);
  prompt += '\n';

  // ========== STYLE GUIDANCE ==========
  prompt += `STYLE & TONE:\n`;
  prompt += `- Educational illustration: suitable for high school textbooks, infographics, or classroom materials.\n`;
  prompt += `- Prioritize CLARITY over decorative beauty. Students should understand the concept at a glance.\n`;
  prompt += `- Use clean lines, high contrast, recognizable forms.\n`;
  prompt += `- Avoid photorealism unless specifically needed for accuracy. Illustrated or simplified forms are preferred.\n`;
  prompt += `- Avoid decorative patterns, complex backgrounds, or superfluous details.\n`;
  prompt += `- The image is a TEACHING TOOL, not fine art.\n`;

  return prompt;
}
```

---

## SECTION 5: STRUCTURED OUTPUT SCHEMA (generateSlidesFromDocument call)

Update the `imageSpecSchema` used in the Gemini structured output call. Find the section where you define `responseSchema`:

**OLD imageSpecSchema:**
```typescript
const imageSpecSchema = {
  type: "object",
  properties: {
    primaryFocal: { type: "string" },
    subjects: { type: "array", items: { type: "string" } },
    actions: { type: "array", items: { type: "string" } },
    mustInclude: { type: "array", items: { type: "string" } },
    avoid: { type: "array", items: { type: "string" } },
    composition: {
      type: "object",
      properties: {
        layout: {
          type: "string",
          enum: ["single-focal-subject-centered", "balanced-pair", "simple-sequence-2-panel"],
        },
        viewpoint: {
          type: "string",
          enum: ["front", "three-quarter", "side", "overhead", "child-eye-level"],
        },
        whitespace: {
          type: "string",
          enum: ["generous", "moderate"],
        },
      },
      required: ["layout", "viewpoint", "whitespace"],
    },
    textPolicy: {
      type: "string",
      enum: ["NO_LABELS", "LIMITED_LABELS_1_TO_3"],
    },
    allowedLabels: { type: "array", items: { type: "string" } },
    colors: { type: "array", items: { type: "string" } },
    negativePrompt: { type: "array", items: { type: "string" } },
  },
  required: ["primaryFocal", "subjects", "mustInclude", "avoid", "composition", "textPolicy"],
};
```

**NEW imageSpecSchema:**
```typescript
const imageSpecSchema = {
  type: "object",
  properties: {
    primaryFocal: { type: "string", description: "One-sentence description of the core visual insight." },
    
    conceptualPurpose: { 
      type: "string", 
      description: "What understanding or insight should students gain from this image? What misconception does it clarify?" 
    },
    
    subjects: {
      type: "array",
      items: { type: "string" },
      description: "3–6 concrete visual elements (things you can draw).",
    },
    
    actions: {
      type: "array",
      items: { type: "string" },
      description: "Optional: 0–3 movements or interactions between subjects.",
    },
    
    mustInclude: {
      type: "array",
      items: { type: "string" },
      description: "3–5 essential visual details that make the concept clear.",
    },
    
    avoid: {
      type: "array",
      items: { type: "string" },
      description: "2+ things to exclude that would confuse or distract.",
    },
    
    composition: {
      type: "object",
      properties: {
        layout: {
          type: "string",
          enum: [
            "single-focal-subject-centered",
            "balanced-pair",
            "simple-sequence-2-panel",
            "comparison-split-screen",
            "diagram-with-flow",
          ],
          description: "How to arrange visual elements.",
        },
        viewpoint: {
          type: "string",
          enum: [
            "front",
            "three-quarter",
            "side",
            "overhead",
            "child-eye-level",
            "side-profile",
            "isometric-3d-cutaway",
          ],
          description: "Camera angle to best show the concept.",
        },
        whitespace: {
          type: "string",
          enum: ["generous", "moderate"],
          description: "How much empty space to leave.",
        },
      },
      required: ["layout", "viewpoint", "whitespace"],
    },
    
    textPolicy: {
      type: "string",
      enum: ["NO_LABELS", "LIMITED_LABELS_1_TO_3"],
      description: "Whether to include text labels in the image.",
    },
    
    allowedLabels: {
      type: "array",
      items: { type: "string" },
      description: "If textPolicy is LIMITED_LABELS_1_TO_3, list 1–3 labels here.",
    },
    
    colors: {
      type: "array",
      items: { type: "string" },
      description: "3–5 hex colors or semantic color descriptions for the image.",
    },
    
    negativePrompt: {
      type: "array",
      items: { type: "string" },
      description: "3–5 common failure modes to prevent.",
    },
  },
  required: [
    "primaryFocal",
    "conceptualPurpose",
    "subjects",
    "mustInclude",
    "avoid",
    "composition",
    "textPolicy",
    "colors",
    "negativePrompt",
  ],
};
```

**Key changes:**
- Added `conceptualPurpose` to `properties` and `required`
- Expanded `layout` enum to include `comparison-split-screen` and `diagram-with-flow`
- Expanded `viewpoint` enum to include `side-profile` and `isometric-3d-cutaway`
- Added descriptions to all properties (helps Gemini understand intent)
- Added `colors` and `negativePrompt` to `required` (no more optional/empty)

---

## SECTION 6: MAIN PROMPT INJECTION (generateSlidesFromDocument)

Find where you inject Section 7 (IMAGE SPECIFICATION) into the main prompt to Gemini 2.5 Pro.

**Replace the entire IMAGE SPECIFICATION section** with the content from the file `optimized-imagespec-prompt.md` (Section 7).

Key points:
- The prompt is now curriculum-agnostic (no RNN examples, no subject-specific guidance)
- It emphasizes `conceptualPurpose` as a key lever for better images
- It explains the new composition and viewpoint options
- It guides on color semantics and negative prompts

---

## SECTION 7: POST-GENERATION VALIDATION & SANITIZATION

In `generateSlidesFromDocument`, after Gemini returns the slides array, add this processing step:

```typescript
// After: const slides = await ... generateContent(...)

// Validate and sanitize each imageSpec
const warnings: string[] = [];

slides.forEach((slide, idx) => {
  if (slide.imageSpec) {
    // 1. Validate
    const errors = validateImageSpec(slide.imageSpec);
    if (errors.length > 0) {
      warnings.push(`Slide ${idx + 1} imageSpec validation errors: ${errors.join('; ')}`);
    }

    // 2. Sanitize (always, even if valid—fills in defaults)
    slide.imageSpec = sanitizeImageSpec(slide.imageSpec, gradeLevel);

    // 3. Format into prompt string
    slide.renderedImagePrompt = formatImageSpec(slide.imageSpec, {
      gradeLevel,
      subject,
    });

    // 4. Hash for change detection (optional but recommended)
    // await to get promise resolved
    hashPrompt(slide.renderedImagePrompt).then(hash => {
      slide.renderedImagePromptHash = hash;
    });
  }
});

// Return slides + warnings
return {
  slides,
  warnings, // Include warnings so UI can display them if needed
  // ... other fields
};
```

**Why this matters:**
- Validation catches Gemini hallucinations early
- Sanitization normalizes arrays and fills in sensible defaults
- Formatting creates the actual image prompt (separate from spec structure)
- Hashing enables detecting when a spec changes and images need regeneration

---

## SECTION 8: GENERATE IMAGE SERVICE (`generateImageFromSpec`)

**NO CHANGES needed to the actual image call**, but ensure the function accepts the formatted prompt:

```typescript
export const generateImageFromSpec = async (
  spec: ImageSpec,
  gradeLevel: string,
  subject: string,
  opts?: ImageGenOptions,
  debugLogging?: boolean
): Promise<{ blob: Blob; renderedPrompt: string }> => {
  // Format the spec into a prompt string
  const renderedPrompt = formatImageSpec(spec, { gradeLevel, subject });

  // Call Gemini image generation with the rendered prompt
  const response = await client.models.generateContent({
    model: 'gemini-3-pro-image-preview', // (or your correct model name)
    contents: [
      {
        role: 'user',
        parts: [
          {
            text: renderedPrompt, // THE FORMATTED PROMPT
          },
        ],
      },
    ],
    generationConfig: {
      temperature: opts?.temperature ?? 0.3,
      responseModalities: ['TEXT', 'IMAGE'],
      imageConfig: {
        aspectRatio: opts?.aspectRatio ?? '16:9',
        imageSize: opts?.imageSize ?? '2K',
      },
    },
  });

  // Extract image from response (as documented)
  const candidatesParts = (response as any).candidates?.[0]?.content?.parts;
  if (!candidatesParts || candidatesParts.length === 0) {
    throw new ImageGenError('No parts in response', 'NO_IMAGE_DATA', false, { parts: candidatesParts });
  }

  const validPart = candidatesParts.find((p: any) => p.inlineData || p.inline_data);
  if (!validPart) {
    throw new ImageGenError(
      'No inlineData found in response parts',
      'NO_IMAGE_DATA',
      false,
      { partsKeys: candidatesParts.map((p: any) => Object.keys(p)) }
    );
  }

  const mimeType = validPart.mimeType || validPart.mime_type || '';
  if (!mimeType.startsWith('image/')) {
    throw new ImageGenError(
      `Invalid MIME type: ${mimeType}`,
      'INVALID_MIME_TYPE',
      false,
      { mimeType }
    );
  }

  const data = validPart.inlineData?.data || validPart.inline_data?.data;
  if (!data) {
    throw new ImageGenError('No image data found in part', 'NO_IMAGE_DATA', false, { part: validPart });
  }

  // Decode base64 to Blob
  const binaryString = atob(data);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  const blob = new Blob([bytes], { type: mimeType });

  if (debugLogging) {
    console.log('Image generation success', {
      mimeType,
      blobSize: blob.size,
      renderedPromptLength: renderedPrompt.length,
    });
  }

  return { blob, renderedPrompt };
};
```

---

## SECTION 9: TESTING CHECKLIST

### Unit Tests (imageUtils.test.ts)

```typescript
describe('validateImageSpec', () => {
  it('rejects spec without conceptualPurpose', () => {
    const spec = { /* no conceptualPurpose */ } as any;
    const errors = validateImageSpec(spec);
    expect(errors.some(e => e.includes('conceptualPurpose'))).toBe(true);
  });

  it('rejects spec with subjects < 3', () => {
    const spec = { subjects: ['one', 'two'] } as any;
    const errors = validateImageSpec(spec);
    expect(errors.some(e => e.includes('subjects'))).toBe(true);
  });

  it('rejects spec with mustInclude > 5', () => {
    const spec = { mustInclude: ['a', 'b', 'c', 'd', 'e', 'f'] } as any;
    const errors = validateImageSpec(spec);
    expect(errors.some(e => e.includes('mustInclude'))).toBe(true);
  });

  it('rejects invalid layout', () => {
    const spec = {
      composition: { layout: 'invalid-layout' },
    } as any;
    const errors = validateImageSpec(spec);
    expect(errors.some(e => e.includes('layout'))).toBe(true);
  });

  it('rejects invalid viewpoint', () => {
    const spec = {
      composition: { viewpoint: 'invalid-viewpoint' },
    } as any;
    const errors = validateImageSpec(spec);
    expect(errors.some(e => e.includes('viewpoint'))).toBe(true);
  });

  it('accepts valid spec', () => {
    const spec: ImageSpec = {
      primaryFocal: 'A clear visualization of the water cycle',
      conceptualPurpose: 'Help students understand the circular flow of water through evaporation, condensation, and precipitation.',
      subjects: ['sun', 'water', 'clouds'],
      mustInclude: [
        'evaporation from a water source',
        'condensation in clouds',
        'precipitation falling',
      ],
      avoid: ['overly complex atmospheric layers', 'photorealistic clouds'],
      composition: {
        layout: 'diagram-with-flow',
        viewpoint: 'side-profile',
        whitespace: 'generous',
      },
      textPolicy: 'NO_LABELS',
      colors: ['#FFD700', '#4CAF50', '#87CEEB', '#F5F5F5'],
      negativePrompt: ['unclear flow direction', 'missing key elements'],
    };

    const errors = validateImageSpec(spec);
    expect(errors.length).toBe(0);
  });
});

describe('sanitizeImageSpec', () => {
  it('clamps subjects to max 6', () => {
    const spec = {
      subjects: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
    } as any;
    const sanitized = sanitizeImageSpec(spec, '9th');
    expect(sanitized.subjects.length).toBeLessThanOrEqual(6);
  });

  it('fills in default conceptualPurpose if missing', () => {
    const spec = {
      primaryFocal: 'Something',
      // no conceptualPurpose
    } as any;
    const sanitized = sanitizeImageSpec(spec, '9th');
    expect(sanitized.conceptualPurpose).toBeTruthy();
    expect(sanitized.conceptualPurpose.length).toBeGreaterThan(0);
  });

  it('sets viewpoint to front for missing viewpoint', () => {
    const spec = {
      composition: { layout: 'single-focal-subject-centered', whitespace: 'generous' },
    } as any;
    const sanitized = sanitizeImageSpec(spec, '9th');
    expect(sanitized.composition.viewpoint).toBe('front');
  });
});

describe('formatImageSpec', () => {
  it('includes conceptualPurpose in output', () => {
    const spec: ImageSpec = {
      primaryFocal: 'Primary',
      conceptualPurpose: 'This is the teaching purpose',
      subjects: ['a', 'b', 'c'],
      mustInclude: ['detail1', 'detail2', 'detail3'],
      avoid: ['bad1', 'bad2'],
      composition: { layout: 'single-focal-subject-centered', viewpoint: 'front', whitespace: 'generous' },
      textPolicy: 'NO_LABELS',
      colors: ['#000', '#FFF', '#999', '#CCC'],
      negativePrompt: ['fail1', 'fail2', 'fail3'],
    };

    const prompt = formatImageSpec(spec, { gradeLevel: '9th', subject: 'Biology' });
    expect(prompt).toContain('TEACHING PURPOSE');
    expect(prompt).toContain('This is the teaching purpose');
  });

  it('includes all required sections', () => {
    const spec: ImageSpec = {
      primaryFocal: 'Primary',
      conceptualPurpose: 'Purpose',
      subjects: ['a', 'b', 'c'],
      mustInclude: ['detail1', 'detail2', 'detail3'],
      avoid: ['bad1', 'bad2'],
      composition: { layout: 'diagram-with-flow', viewpoint: 'side-profile', whitespace: 'generous' },
      textPolicy: 'LIMITED_LABELS_1_TO_3',
      allowedLabels: ['Label1', 'Label2'],
      colors: ['#000', '#FFF', '#999', '#CCC'],
      negativePrompt: ['fail1', 'fail2', 'fail3'],
    };

    const prompt = formatImageSpec(spec, { gradeLevel: '10th', subject: 'Math' });
    expect(prompt).toContain('CONTEXT');
    expect(prompt).toContain('PRIMARY VISUAL CONCEPT');
    expect(prompt).toContain('VISUAL ELEMENTS');
    expect(prompt).toContain('MUST INCLUDE');
    expect(prompt).toContain('COMPOSITION');
    expect(prompt).toContain('TEXT POLICY');
    expect(prompt).toContain('COLORS');
    expect(prompt).toContain('AVOID');
    expect(prompt).toContain('NEGATIVE PROMPT');
  });
});
```

### Integration Tests
- Mock Gemini response with new `conceptualPurpose` field
- Call `generateSlidesFromDocument` and verify imageSpec is present
- Call `generateImageFromSpec` with a well-formed spec and verify image is generated

### E2E Manual Tests
1. **Create a new deck** from source material (any subject, any grade 6–12)
2. **Inspect the generated imageSpec** in the browser console or Firestore:
   - Verify `conceptualPurpose` is present and substantive
   - Verify `layout` and `viewpoint` are expanded options (e.g., `diagram-with-flow`, `isometric-3d-cutaway`)
   - Verify `subjects` is 3–6 items, `mustInclude` is 3–5 items
3. **Check the rendered prompt** (displayed in UI or logged):
   - Verify "TEACHING PURPOSE" appears near the top
   - Verify "VISUAL ELEMENTS", "MUST INCLUDE", "COMPOSITION" sections are present
4. **Generate images** and verify they:
   - Are concept-focused, not generic
   - Reflect the composition and viewpoint specified
   - Use the specified color palette
   - Show the "must include" elements prominently
5. **Test edge cases:**
   - Deck with many slides (10+) – verify all imageSpecs are generated and valid
   - Deck with complex topic (e.g., AP Chemistry) – verify spec is specific and sensible
   - Deck with simple topic (e.g., 6th grade social studies) – verify simplification is appropriate for grade level

---

## SECTION 10: DEPLOYMENT & ROLLOUT

1. **Update types and enums** (`types.ts`)
2. **Update validators and sanitizers** (`imageUtils.ts`)
3. **Update formatter** (`imageUtils.ts`)
4. **Update schema** (in `generateSlidesFromDocument` call site)
5. **Update main prompt** (inject new Section 7 from `optimized-imagespec-prompt.md`)
6. **Add post-generation processing** (validation → sanitization → formatting)
7. **Write tests** and verify all pass
8. **Manual E2E testing** (create 2–3 decks across different subjects/grades)
9. **Verify image quality** (are images more concept-focused and instructive?)
10. **Deploy** to dev/staging for QA review

---

## SECTION 11: COMMON PITFALLS & MITIGATIONS

| Pitfall | Cause | Mitigation |
|---------|-------|-----------|
| Images still generic | Gemini ignores `conceptualPurpose` | Ensure prompt leads with teaching purpose (done in Section 4). If still generic, consider prompt engineering with stronger language. |
| Validation rejects good specs | Ranges too strict (e.g., subjects 3–6 is wrong for your topic) | Adjust numeric ranges in validator to match your domain. This spec assumes 3–6 subjects; adjust if needed. |
| `diagram-with-flow` never generated | Model doesn't understand new layout | Add examples to prompt. Section 7 of main prompt has examples; ensure they mention `diagram-with-flow`. |
| Old tests fail | Enums/schema changed | Update test fixtures to use new enums and required `conceptualPurpose`. |
| Backward compat issues | Code still checks for old fields (e.g., `imagePrompt` instead of `imageSpec`) | No backward compat required in dev. Delete/rebuild all test decks. |

---

## SECTION 12: SUCCESS CRITERIA

After refactor, the image pipeline should satisfy:

- [ ] **All imageSpecs include `conceptualPurpose`** (required field, validated, non-empty)
- [ ] **Validator enforces new numeric ranges** (subjects 3–6, mustInclude 3–5, etc.)
- [ ] **Schema includes new layout/viewpoint options** and examples appear in generated specs
- [ ] **Formatted prompt starts with "TEACHING PURPOSE"** and uses all spec fields
- [ ] **Generated images are concept-focused**, not generic:
  - Domain expert seeing image without text understands the teaching idea
  - Image uses specified color semantics
  - Image reflects composition and viewpoint choices
- [ ] **No validation errors on any generated spec** (or errors are logged/visible for debugging)
- [ ] **All unit tests pass** (validators, sanitizers, formatter)
- [ ] **E2E test decks generate images successfully** across diverse subjects/grades
- [ ] **Image quality improved vs. baseline** (subjective: images are more instructive, less simplistic)

---

## APPENDIX: File Checklist

**Files to modify:**

1. **`types.ts`**
   - [ ] Update `ImageLayout` enum (add `comparison-split-screen`, `diagram-with-flow`)
   - [ ] Update `Viewpoint` enum (add `side-profile`, `isometric-3d-cutaway`)
   - [ ] Add `conceptualPurpose: string` to `ImageSpec` interface

2. **`imageUtils.ts`**
   - [ ] Replace `validateImageSpec()` with new version (Section 2)
   - [ ] Replace `sanitizeImageSpec()` with new version (Section 3)
   - [ ] Replace `formatImageSpec()` with new version (Section 4)

3. **`generateSlidesFromDocument.ts` (or relevant deck-generation file)**
   - [ ] Update `imageSpecSchema` structured output schema (Section 5)
   - [ ] Replace "Section 7: IMAGE SPECIFICATION" prompt text with content from `optimized-imagespec-prompt.md` (Section 6)
   - [ ] Add post-generation validation/sanitization step (Section 7)

4. **`generateImageFromSpec.ts` (or relevant service)**
   - [ ] Ensure function calls `formatImageSpec()` to create rendered prompt (no other changes needed)

5. **Test files**
   - [ ] Create/update `imageUtils.test.ts` with new test suite (Section 9)

---

## Questions for Cursor During Implementation

If you encounter any of these, pause and clarify:

1. **"What is the current model name for image generation?"** – Code assumes `gemini-3-pro-image-preview`, but verify correct model string.
2. **"Where is the imageSpecSchema defined?"** – Find the exact call to `generateContent()` that passes `responseSchema` for deck generation.
3. **"Are there any UI components that display imageSpec or renderedImagePrompt?"** – If so, they may need updates to show `conceptualPurpose`.
4. **"Is there a specific numeric range that breaks tests?"** – If your test data uses different subject/mustInclude counts, adjust validator accordingly.
5. **"Is backward compat actually zero?"** – Confirm all test decks will be regenerated (not loaded from prior versions).

---

**End of Refactor Specification**

This is a complete, detailed refactor guide. All sections are implementation-ready. Cursor can follow Section by Section and copy/paste functions directly.
