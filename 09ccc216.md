# SlidesEdu Image Generation Refactor - Cursor Implementation Feedback

**Status:** Implementation Plan Review  
**Date:** December 15, 2025  
**Reviewer:** Architecture & QA  
**Audience:** Antigravity

---

## Executive Summary

The proposed implementation plan is **solid and well-structured**. The modular breakdown into Types, Utilities, and Service Logic is correct. However, there are several **critical details** and **edge cases** that need clarification before proceeding, plus some **recommended optimizations** and **additional verification steps**.

This document provides feedback organized by **priority level**: Critical (must fix), High (strongly recommend), Medium (nice to have), and Low (nice to know).

---

## 1. CRITICAL FEEDBACK

### 1.1 Image API Configuration – Verify Actual Response Structure

**Issue:** The spec assumes `gemini-3-pro-image-preview` returns image data in `.candidates[0].content.parts[]` with `.inlineData` or `.inline_data`. This needs **runtime verification** before implementation.

**Current extraction code:**
```ts
const candidatesParts = (response as any).candidates?.[0]?.content?.parts;
const validPart = parts.find((p: any) => p.inlineData || p.inline_data);
```

**Action Required:**
- [ ] Before finalizing `generateImageFromSpec`, test a real call to `gemini-3-pro-image-preview` with the new config:
  ```ts
  config: {
    temperature,
    responseModalities: ['TEXT', 'IMAGE'],
    imageConfig: {
      aspectRatio,
      imageSize,
    },
  }
  ```
- [ ] Log the **full response structure** (sanitized) to verify:
  - Where image data actually lives in the response object
  - Whether `.responseModalities: ['TEXT', 'IMAGE']` causes both text and image to be returned
  - What the MIME type is (verify it's actually `image/png` or `image/jpeg`)
- [ ] **If structure differs**, update the extraction logic **before** merging to main

**Risk:** Silent failure if extraction doesn't find image data; users see "No image data found in response" but spec seems correct.

**Recommendation:** Add a **detailed logging mode** for image generation:
```ts
export const generateImageFromSpec = async (
  spec: ImageSpec,
  gradeLevel: string,
  subject: string,
  opts?: ImageGenOptions,
  debugLogging: boolean = false
): Promise<{ blob: Blob; renderedPrompt: string }> => {
  // ... existing code
  
  if (debugLogging) {
    console.log('Image generation response structure:', {
      candidatesCount: (response as any).candidates?.length,
      firstCandidateKeys: Object.keys((response as any).candidates?.[0] || {}),
      contentKeys: Object.keys((response as any).candidates?.[0]?.content || {}),
      partsCount: parts?.length,
      firstPartKeys: parts?.[0] ? Object.keys(parts[0]) : [],
    });
  }
```

---

### 1.2 Structured Output Compatibility – Check SDK Support

**Issue:** The plan uses `responseSchema` and `responseMimeType` for both Gemini 2.5 Pro and Gemini 2.5 Pro in `regenerateImageSpec`. The `@google/genai` SDK may have different versions or compatibility quirks.

**Action Required:**
- [ ] Verify the exact SDK version in `package.json`:
  ```json
  "@google/genai": "^X.X.X"
  ```
- [ ] Test that `responseMimeType: "application/json"` + `responseSchema` work together in both:
  - `generateSlidesFromDocument` (already working, but needs re-verification after schema changes)
  - `regenerateImageSpec` (new usage; untested)
- [ ] If structured outputs are **not supported** in your SDK version, you'll need to:
  - Fall back to parsing JSON from raw text response (less reliable)
  - Or upgrade the SDK

**Recommendation:** Add a schema compatibility check in a utility:
```ts
// lib/schemaUtils.ts
export function validateStructuredOutputSupport(sdkVersion: string): boolean {
  // Structured outputs require @google/genai >= 0.x.x (verify actual version)
  const [major, minor] = sdkVersion.split('.').map(Number);
  return major > 0 || (major === 0 && minor >= 4); // Example threshold
}
```

---

### 1.3 Backward Compatibility – imagePrompt Must Still Work

**Issue:** The plan says "existing decks with imagePrompt will continue to work," but the implementation details are vague.

**Current situation:**
- Old decks have `imagePrompt: string` and no `imageSpec`
- New code will try to access `slide.imageSpec` in `generateImageFromSpec`
- If `imageSpec` is missing, the code will throw or fail silently

**Action Required:**
- [ ] Implement a **fallback adapter** function:
  ```ts
  // lib/imageUtils.ts
  export function ensureImageSpec(slide: Slide, gradeLevel: string, subject: string): ImageSpec {
    // If spec exists, return it
    if (slide.imageSpec) {
      return slide.imageSpec;
    }
    
    // If only imagePrompt exists, return a minimal spec
    // (Not ideal, but keeps old decks functional)
    if (slide.imagePrompt) {
      return {
        primaryFocal: slide.imagePrompt.substring(0, 100), // First 100 chars as focal
        subjects: ['visual aid object'],
        mustInclude: ['visual element'],
        avoid: ['clutter', 'text'],
        composition: {
          layout: 'single-focal-subject-centered',
          viewpoint: 'front',
          whitespace: 'generous',
        },
        textPolicy: 'NO_LABELS',
      };
    }
    
    throw new Error('Slide has neither imageSpec nor imagePrompt');
  }
  ```
  
- [ ] Call this adapter in `generateImageFromSpec` before processing:
  ```ts
  const spec = ensureImageSpec(slide, gradeLevel, subject);
  const renderedPrompt = formatImageSpec(spec, { gradeLevel, subject });
  ```

- [ ] **Document this behavior** in code comments so future devs understand the bridge

**Risk:** Existing decks fail silently or with cryptic errors if fallback is not implemented.

---

### 1.4 Validation & Sanitization – Must Happen Before Any API Call

**Issue:** If `imageSpec` from Gemini is malformed, and you don't validate before using it, you'll get poor images or errors.

**Current plan mentions:**
- `validateImageSpec` for error detection
- `sanitizeImageSpec` for coercion

**Action Required:**
- [ ] Ensure validation happens **immediately after** Gemini returns specs in `generateSlidesFromDocument`:
  ```ts
  slides.forEach((slide, idx) => {
    if (slide.imageSpec) {
      const errors = validateImageSpec(slide.imageSpec);
      if (errors.length > 0) {
        warnings.push(`Slide ${idx + 1} imageSpec errors: ${errors.join('; ')}`);
      }
      
      // Always sanitize, even if valid (fills in defaults, clamps arrays)
      slide.imageSpec = sanitizeImageSpec(slide.imageSpec, gradeLevel);
      
      // Then format
      slide.renderedImagePrompt = formatImageSpec(slide.imageSpec, { gradeLevel, subject });
    }
  });
  ```

- [ ] Document that **warnings are non-fatal** (images still generate, but with defaults):
  ```ts
  // types.ts
  export interface GenerateSlidesResponse {
    slides: Slide[];
    warnings: string[]; // Includes validation warnings
    // ...
  }
  ```

**Risk:** Bad specs silently degrade image quality instead of being caught and reported.

---

## 2. HIGH PRIORITY FEEDBACK

### 2.1 renderedImagePrompt Storage – Where Does It Live?

**Issue:** The plan generates `renderedImagePrompt` locally but doesn't clarify **where it's stored** and **how it persists**.

**Questions:**
- Is `renderedImagePrompt` stored in Firestore as a field on each slide?
- Or is it computed on-the-fly from `imageSpec` each time it's needed?
- Should it be indexed/searchable?

**Recommendation:**
- [ ] **Store both** in Firestore:
  - `imageSpec: ImageSpec` (the source of truth)
  - `renderedImagePrompt: string` (the display/submission value)
- [ ] Add a `renderedImagePromptHash: string` field for cache-busting:
  ```ts
  import crypto from 'crypto';
  
  export function hashPrompt(prompt: string): string {
    return crypto.createHash('sha256').update(prompt).digest('hex');
  }
  ```
- [ ] This hash can be used to detect if a spec changed and regenerate images:
  ```ts
  // If hashPrompt(newPrompt) !== oldHash, it's a new prompt
  // Consider re-generating the image automatically or flagging for re-gen
  ```

**Firestore schema:**
```ts
interface SlideDocument {
  // ... existing fields
  imageSpec?: ImageSpec;
  renderedImagePrompt?: string;
  renderedImagePromptHash?: string;
  lastImageGenAt?: Timestamp;
  lastImageGenSettings?: ImageGenOptions;
}
```

---

### 2.2 Error Handling in generateImageFromSpec – Be Explicit

**Issue:** The current error handling is generic. We need specific error types and recovery strategies.

**Action Required:**
- [ ] Expand error handling:
  ```ts
  export class ImageGenError extends Error {
    constructor(
      message: string,
      public code: 'NO_IMAGE_DATA' | 'INVALID_MIME_TYPE' | 'NETWORK' | 'TIMEOUT' | 'UNKNOWN',
      public isRetryable: boolean,
      public context?: any
    ) {
      super(message);
      this.name = 'ImageGenError';
    }
  }
  
  export const generateImageFromSpec = async (...) => {
    try {
      // ... Gemini call
      
      if (!parts || parts.length === 0) {
        throw new ImageGenError('No parts in response', 'NO_IMAGE_DATA', false, { parts });
      }
      
      if (!validPart) {
        throw new ImageGenError('No inlineData found in parts', 'NO_IMAGE_DATA', false, { partsKeys: parts.map(p => Object.keys(p)) });
      }
      
      if (!mimeType.startsWith('image/')) {
        throw new ImageGenError(`Invalid mimeType: ${mimeType}`, 'INVALID_MIME_TYPE', false, { mimeType });
      }
      
      // ... rest of logic
    } catch (error) {
      if (error instanceof ImageGenError) throw error;
      
      const isNetworkError = error?.message?.includes('network') || error?.code === 'ECONNRESET';
      const isTimeout = error instanceof GeminiError && error.code === 'TIMEOUT';
      
      throw new ImageGenError(
        error?.message || 'Unknown error',
        isNetworkError ? 'NETWORK' : isTimeout ? 'TIMEOUT' : 'UNKNOWN',
        isNetworkError || isTimeout,
        error
      );
    }
  };
  ```

- [ ] This allows the UI to show different recovery options:
  - `isRetryable && code === 'NETWORK'` → "Check your connection and try again"
  - `code === 'NO_IMAGE_DATA'` → "Spec is malformed; try a different visual idea"

---

### 2.3 UI: renderedImagePrompt Display & Editing

**Issue:** Plan says "update Editor.tsx to display renderedImagePrompt" but doesn't clarify the **interaction model**.

**Questions:**
- Is the prompt shown as read-only text?
- Can users edit it directly?
- If they edit it, how does it map back to `imageSpec`?
- Or is it just for copying/sharing?

**Recommended Behavior:**
- [ ] Show as **read-only** by default (formatted from spec)
- [ ] Add an "Edit" mode that:
  - Lets users modify the prompt text
  - On save, attempts to **infer spec changes** (hard) or just re-generate the image with the new prompt text
  - **Or** shows a warning: "Editing directly changes the prompt but not the spec. 'New Visual Idea' regenerates the spec."
- [ ] Add a "Copy prompt" button for users who want to use it elsewhere

**UI pseudocode:**
```tsx
<ImagePromptDisplay
  renderedPrompt={slide.renderedImagePrompt}
  onEditClick={() => setEditMode(true)}
  onRegenerateImage={() => regenerateImageFromSameSpec()} // new temperature
  onNewVisualIdea={() => regenerateImageSpec()} // new spec via Gemini
  onCopyClick={() => clipboard.copy(slide.renderedImagePrompt)}
/>
```

---

### 2.4 Temperature Parameter – Add Consistency Control

**Issue:** The spec mentions `temperature: 0.3` as default, but for "regenerate image" (same spec), users might want:
- Lower temperature (more consistent, deterministic)
- Higher temperature (more variation)

**Current implementation leaves this to the caller**, but the UI needs to expose it.

**Recommendation:**
- [ ] Add a "Variation" slider or preset buttons in UI:
  ```tsx
  <button onClick={() => regenerateImageFromSameSpec(temperature=0.1)}>
    Generate Similar
  </button>
  <button onClick={() => regenerateImageFromSameSpec(temperature=0.4)}>
    Generate With Variation
  </button>
  ```

- [ ] Document temp ranges in UI:
  - 0.0–0.2 = very consistent, photorealistic → not ideal for educational
  - 0.3–0.5 = good for variety, still recognizable
  - 0.6+ = high variation, may diverge from spec intent

---

## 3. MEDIUM PRIORITY FEEDBACK

### 3.1 Image Size (1K, 2K, 4K) – Make it User-Configurable

**Issue:** Plan defaults `imageSize: '2K'`, but different use cases want different sizes:
- K-12 classroom slides: 2K is good (1920×1080 or 2560×1440)
- Print: might want 4K
- Web preview: might want 1K to save tokens

**Recommendation:**
- [ ] Store `defaultImageSize` in deck settings:
  ```ts
  interface DeckSettings {
    defaultAspectRatio: '16:9' | '1:1';
    defaultImageSize: '1K' | '2K' | '4K';
    defaultImageTemperature: number;
  }
  ```

- [ ] Add a "Image Quality" selector in UI (deck-level or per-slide):
  ```tsx
  <select value={deck.defaultImageSize} onChange={updateImageSize}>
    <option value="1K">1K (smaller, faster)</option>
    <option value="2K">2K (balanced)</option>
    <option value="4K">4K (highest quality)</option>
  </select>
  ```

---

### 3.2 negativePrompt Array – Ensure It's Not Empty

**Issue:** The schema allows `negativePrompt: []` (empty), but the formatter includes it in the avoid list. Empty arrays waste space.

**Recommendation:**
- [ ] In `sanitizeImageSpec`, ensure `negativePrompt` is populated if empty:
  ```ts
  if (!spec.negativePrompt || spec.negativePrompt.length === 0) {
    spec.negativePrompt = [
      'misspelled text',
      'gibberish',
      'confusing details',
    ];
  }
  ```

- [ ] Or adjust the formatter to skip empty arrays:
  ```ts
  const negativesStr = avoidList.length > 0 
    ? `- ${avoidList.join('\n- ')}`
    : '';
  ```

---

### 3.3 Grade Level Parsing – Handle Edge Cases

**Issue:** `sanitizeImageSpec` does `parseInt(gradeLevel, 10)` on values like "2nd", "5th", etc., which returns NaN.

**Recommendation:**
- [ ] Add a robust parser:
  ```ts
  export function parseGradeLevel(gradeLevel: string): number {
    const match = gradeLevel.match(/(\d+)/);
    if (match) return parseInt(match[1], 10);
    
    const names: Record<string, number> = {
      'K': 0, 'Kindergarten': 0,
      'Pre-K': -1,
      '1st': 1, '1': 1,
      '2nd': 2, '2': 2,
      // ... etc
    };
    
    return names[gradeLevel] ?? 3; // default to grade 3
  }
  ```

- [ ] Use it in `sanitizeImageSpec`:
  ```ts
  const gradeNum = parseGradeLevel(gradeLevel);
  if (!clone.composition.viewpoint) {
    clone.composition.viewpoint = gradeNum <= 2 ? 'child-eye-level' : 'front';
  }
  ```

---

### 3.4 Test Coverage – Outline What Needs Testing

**Issue:** Plan mentions "manual verification" but doesn't specify what automated tests are needed.

**Recommendation:**
- [ ] Add unit tests for utilities:
  ```ts
  // __tests__/imageUtils.test.ts
  describe('validateImageSpec', () => {
    it('rejects spec without primaryFocal', () => {
      const errors = validateImageSpec({ /* no primaryFocal */ });
      expect(errors).toContain(expect.stringContaining('primaryFocal'));
    });
    
    it('accepts valid spec', () => {
      const errors = validateImageSpec({ 
        primaryFocal: 'leaf in sunlight',
        subjects: ['leaf', 'sun'],
        mustInclude: ['leaf', 'sun'],
        avoid: ['text', 'clutter'],
        composition: { ... },
        textPolicy: 'NO_LABELS',
      });
      expect(errors.length).toBe(0);
    });
  });
  
  describe('formatImageSpec', () => {
    it('includes all required sections', () => {
      const prompt = formatImageSpec(validSpec, { gradeLevel: '5th', subject: 'Science' });
      expect(prompt).toContain('Primary focus:');
      expect(prompt).toContain('Avoid:');
      expect(prompt).toContain('5th grade');
    });
  });
  ```

- [ ] Add integration tests for `generateImageFromSpec`:
  - Mock Gemini API response
  - Verify image extraction logic works

---

## 4. LOW PRIORITY / NICE TO HAVE

### 4.1 Caching Layer for Generated Prompts

**Issue:** If the same spec is rendered multiple times, we recompute the prompt.

**Recommendation:**
- [ ] Add a simple in-memory cache:
  ```ts
  const promptCache = new Map<string, string>();
  
  export function formatImageSpec(spec: ImageSpec, ctx: FormatContext): string {
    const key = JSON.stringify({ spec, ctx });
    if (promptCache.has(key)) return promptCache.get(key)!;
    
    const prompt = /* ... existing logic ... */;
    promptCache.set(key, prompt);
    return prompt;
  }
  ```

---

### 4.2 Telemetry – Track Image Generation Success Rates

**Issue:** We don't know if images are failing silently or what specs cause issues.

**Recommendation:**
- [ ] Log key events:
  ```ts
  // lib/telemetry.ts
  export const imageGenTelemetry = {
    onSpecValidation: (errors: string[], slideIdx: number) => {
      if (errors.length > 0) {
        logEvent('image_spec_validation_failed', {
          slideIndex: slideIdx,
          errorCount: errors.length,
          errors: errors.join('; '),
        });
      }
    },
    
    onImageGenSuccess: (spec: ImageSpec, imageSize: string) => {
      logEvent('image_generation_success', {
        imageSize,
        textPolicy: spec.textPolicy,
        layoutType: spec.composition.layout,
      });
    },
    
    onImageGenFailure: (error: ImageGenError, slideIdx: number) => {
      logEvent('image_generation_failed', {
        slideIndex: slideIdx,
        errorCode: error.code,
        isRetryable: error.isRetryable,
      });
    },
  };
  ```

---

## 5. VERIFICATION PLAN – ENHANCED

The proposed manual verification is good. Here's an **expanded checklist** to ensure quality:

### 5.1 Unit Tests (Before Integration)
- [ ] `validateImageSpec` with valid/invalid specs
- [ ] `sanitizeImageSpec` with edge cases (empty arrays, missing fields, grade level parsing)
- [ ] `formatImageSpec` output includes all sections and respects textPolicy
- [ ] `parseGradeLevel` with various input formats

### 5.2 Integration Tests (With Mocked Gemini)
- [ ] `generateSlidesFromDocument` returns slides with `imageSpec` and `renderedImagePrompt`
- [ ] `generateImageFromSpec` with mocked response correctly extracts image data
- [ ] Fallback for old `imagePrompt` works (if implementing)
- [ ] `regenerateImageSpec` returns valid ImageSpec via structured output

### 5.3 Manual Testing (E2E)
- [ ] **Create new deck:**
  - Verify imageSpec is generated for each content slide (check console/network)
  - Verify renderedImagePrompt appears in UI
  - Verify images are generated and displayed correctly
  
- [ ] **Regenerate Image (same spec):**
  - Click "Regenerate Image"
  - Verify new image appears (different rendering of same concept)
  - Verify prompt stays the same

- [ ] **Regenerate Spec (new visual idea):**
  - Click "New Visual Idea"
  - Verify new imageSpec is generated (check console)
  - Verify renderedImagePrompt changes in UI
  - Verify new image is generated and different from before

- [ ] **Edge cases:**
  - Deck with 1 slide → verify only content slide gets imageSpec
  - Deck with many bullets (20+) → verify sanitization clamps to 6
  - Deck with no subject/gradeLevel → verify defaults apply
  - Network error during image gen → verify retry logic works

- [ ] **Legacy fallback (if implemented):**
  - Load old deck with only imagePrompt
  - Verify images still generate using fallback adapter
  - Verify no errors in console

### 5.4 Performance Tests
- [ ] Generating a 10-slide deck with images takes < 60s (including retries)
- [ ] formatImageSpec() takes < 5ms
- [ ] Image extraction doesn't block UI
- [ ] No memory leaks in image storage

---

## 6. SUMMARY OF ACTION ITEMS FOR CURSOR

**Before Implementation:**
- [ ] **CRITICAL:** Test real Gemini 3 Pro Image API response structure with new config
- [ ] **CRITICAL:** Verify @google/genai SDK version supports structured outputs
- [ ] **CRITICAL:** Implement fallback adapter for old imagePrompt
- [ ] **CRITICAL:** Add spec validation immediately after Gemini returns data

**During Implementation:**
- [ ] Expand error handling with specific error types
- [ ] Add grade level parser that handles edge cases
- [ ] Implement deterministic formatter with all required sections
- [ ] Wire up Firestore schema for imageSpec, renderedImagePrompt, promptHash
- [ ] Add telemetry for image gen success/failure

**After Implementation:**
- [ ] Run unit tests on validators and formatters
- [ ] Run integration tests with mocked Gemini
- [ ] Run manual E2E tests (new deck, regenerations, edge cases)
- [ ] Performance test on 10+ slide decks
- [ ] Verify legacy fallback works (if applicable)

---

## 7. RISK ASSESSMENT

| Risk | Severity | Mitigation |
|------|----------|-----------|
| Image API response structure differs from current extraction | **HIGH** | Test real API call first; add debug logging |
| Spec validation fails silently, poor images result | **HIGH** | Always validate + sanitize before use |
| Old decks break without fallback adapter | **HIGH** | Implement fallback immediately |
| Structured output not supported in SDK | **MEDIUM** | Check SDK version early; have fallback parser |
| UI unclear on regeneration modes | **MEDIUM** | Clear button labels + tooltips ("Regenerate Image" vs "New Visual Idea") |
| Image gen success rate drops vs. current flow | **MEDIUM** | Compare metrics before/after; have rollback plan |

---

## 8. GO/NO-GO DECISION

**Recommendation:** ✅ **PROCEED** with implementation

**Conditions:**
1. ✅ CRITICAL items 1.1–1.4 must be resolved before merging
2. ✅ Unit tests (section 5.1) must pass
3. ✅ Manual E2E tests (section 5.3) must cover all regeneration modes
4. ✅ Fallback adapter for old decks must be in place

**Estimated Timeline:**
- Implementation: 3–4 days (types, utilities, service logic, UI wiring)
- Testing: 2–3 days (unit, integration, manual)
- **Total: 5–7 days**

---

## 9. APPENDIX: Code Snippets for Cursor Reference

### A. ImageSpec Type (types.ts)
Already defined in spec; reference section 4 of the markdown refactor doc.

### B. validateImageSpec (imageUtils.ts)
Already defined in spec; reference section 9.1 of the markdown refactor doc.

### C. Enhanced Error Handling (section 2.2 of this feedback)
```ts
export class ImageGenError extends Error {
  constructor(
    message: string,
    public code: 'NO_IMAGE_DATA' | 'INVALID_MIME_TYPE' | 'NETWORK' | 'TIMEOUT' | 'UNKNOWN',
    public isRetryable: boolean,
    public context?: any
  ) {
    super(message);
    this.name = 'ImageGenError';
  }
}
```

### D. Fallback Adapter (section 1.3 of this feedback)
```ts
export function ensureImageSpec(slide: Slide, gradeLevel: string, subject: string): ImageSpec {
  if (slide.imageSpec) return slide.imageSpec;
  
  if (slide.imagePrompt) {
    return {
      primaryFocal: slide.imagePrompt.substring(0, 100),
      subjects: ['visual aid'],
      mustInclude: ['educational element'],
      avoid: ['clutter', 'text'],
      composition: { layout: 'single-focal-subject-centered', viewpoint: 'front', whitespace: 'generous' },
      textPolicy: 'NO_LABELS',
    };
  }
  
  throw new Error('Slide missing imageSpec and imagePrompt');
}
```

---

## End of Feedback Document

**Questions?** Refer to the main markdown spec (`slidesedu-image-refactor.md`) for detailed implementation guidance.
